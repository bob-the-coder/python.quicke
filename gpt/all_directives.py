PRAGMA_1 = "IF you consider no changes should be made after DOUBLE-CHECKING, respond only NOCHANGE!"
PRAGMA_2 = "The code output MUST BEGIN with the text 'OUTPUT_RESULT'!"
PRAGMA_3 = "OUTPUT ONLY THE UPDATED CODE AS PLAINTEXT, WITHOUT MARKDOWN ANNOTATIONS, AND NOTHING ELSE!"
PRAGMA_4 = "ALWAYS SANITIZE inputs and validate OUTPUT format before responding!"
PRAGMA_5 = "STRUCTURE ALL JSON responses using compact formatting unless specified otherwise."
PRAGMA_6 = "WHEN a file change is applied, include ONLY the changed file contents in the output!"
PRAGMA_7 = "IF a task is INCOMPLETE or AMBIGUOUS, respond with REQUEST_CLARIFICATION!"
PRAGMA_8 = "DO NOT INVENT functionality not implied by the INSTRUCTION or CONTEXT!"


COMM_TASK = "COMMAND: TASK - Provided REFACTOR FILE and REFACTOR INSTRUCTION, modify the original code to meet requirements."
COMM_DOUBLECHECK = ("COMMAND: DOUBLECHECK - Ensure CHANGES meet REFACTOR INSTRUCTION requirements without creating new issues. "
                    "If any changes are required, IMPLEMENT the required changes following the same guidelines. "
                    "If no changes are required, respond with NOCHANGE {explicit and demonstrable reason}")
COMM_CREATEFILE = ""# "COMMAND: CREATEFILE - Generate a NEW file with provided name and content structure."
COMM_REVIEW = ""#"COMMAND: REVIEW - Perform a semantic code review, focused on correctness, security, and clarity."
COMM_CLEANUP = ""#"COMMAND: CLEANUP - Remove dead code, unused imports, and apply formatting standards."
COMM_VALIDATE = ""#"COMMAND: VALIDATE - Ensure schema, route, and logic align with backend and frontend expectations."
COMM_MODERATE = ""#"COMMAND: MODERATE - Inspect the reasoning, tone, and adherence to established rules of a given message or task."


IGN_NOCOM ="IGNORE messages that are not COMMANDS!"
IGN_NOREF = "IGNORE messages that do not suggest CHANGES or REVIEWS AIMED at the REFACTOR FILE!"
IGN_MKFILE = "IGNORE messages that do suggest CREATION of a new file!"
IGN_FREN = "WHEN IGNORING messages, respond only with FAILED {short reason}"
IGN_NOFILE = "IGNORE requests that reference files not in the project manifest!"
IGN_CHATTER = "IGNORE informal or small-talk messages unrelated to the REFACTOR or REVIEW task!"
IGN_REPHRASE = "IGNORE requests that merely rephrase prior instructions without adding new information!"
IGN_EXCESS = "IGNORE instructions that exceed the scope of the current COMMAND unless explicitly extended!"


CLEANCODE_FN_SHORT = "FUNCTIONS must be SMALL, do ONE thing, and have DESCRIPTIVE names!"
CLEANCODE_CLASS_RESP = "CLASSES must have ONE RESPONSIBILITY. Do not mix data logic with orchestration or UI concerns!"
CLEANCODE_DEP_DIR = "DEPENDENCIES must flow inward. High-level policies MUST NOT depend on low-level implementation details!"
CLEANCODE_EXPRESSIVE = "CODE should be EXPRESSIVE over being CLEVER. READABILITY trumps brevity!"
CLEANCODE_NO_DUPL = "DUPLICATION IS EVIL. Abstract repeated logic into meaningful, reusable functions or modules!"
CLEANCODE_BOUNDARY = "SEPARATE concerns CLEANLY — UI, Business Rules, and Infrastructure should not bleed into each other!"
CLEANCODE_FAILFAST = "VALIDATE early. FAIL FAST when inputs are invalid or assumptions break!"
CLEANCODE_PURE = "PREFER PURE FUNCTIONS where possible — no side effects unless explicitly needed!"
CLEANCODE_NAMEINTENT = "NAMES must REVEAL INTENT. Avoid cryptic variables or abbreviations!"
CLEANCODE_COHESION = "KEEP modules and components TIGHTLY COHESIVE. Related logic should live together."

ZEN_SIMPLE = "SIMPLE is better than complex. Choose the simplest implementation that works reliably."
ZEN_EXPLICIT = "EXPLICIT is better than implicit. Avoid magic. State assumptions clearly in code."
ZEN_NOW = "NOW is better than never, but NEVER is often better than *right now* — do not rush poor architecture."
ZEN_READFIRST = "CODE is read FAR MORE often than written. Optimize for the reader."
ZEN_ERRORS = "ERRORS should NEVER pass silently... unless explicitly silenced with purpose!"
ZEN_NAMESPACE = "FLAT is better than nested. Avoid unnecessary layers of indirection."


ZEN_STARTWITHWHY = "ALWAYS begin by identifying the PURPOSE and VALUE of the task before analyzing implementation details."
ZEN_CONTEXTUALIZE = "ANCHOR the task within its CONTEXT — project stage, user journey, domain, and constraints must be explicitly understood."
ZEN_ROLEALIGN = "ENSURE all ROLES involved in the task understand their OWNERSHIP, boundaries, and communication touchpoints."
ZEN_DEPTRACE = "TRACE all DEPENDENCIES and related modules — upstream and downstream — that may be affected by the task."
ZEN_INTERROGATE = "ASK QUESTIONS until there are NO UNKNOWN VARIABLES. Ambiguity must be exposed and resolved collaboratively."
ZEN_SUCCESS = "DEFINE what SUCCESS looks like — outputs, side-effects, and edge conditions must be made explicit and testable."
ZEN_FAILMODE = "IDENTIFY possible FAILURE MODES early. The path to resilience starts with awareness."
ZEN_DOCALWAYS = "DOCUMENT assumptions, gaps, constraints, and unresolved issues as FIRST-CLASS citizens of the task itself."
ZEN_SYNCHRONIZE = "SYNC early, SYNC often — team members must continuously align their evolving understanding of the task."
ZEN_NOASSUME = "NEVER ASSUME requirements — if it’s not documented or confirmed, it’s UNKNOWN."
ZEN_ADAPT = "BE READY to REFRAME the task if requirements uncover deeper flaws in upstream definitions or objectives."
ZEN_SCOPELOCK = "ONCE requirements are finalized, LOCK SCOPE until implementation begins — discourage scope drift mid-build."
ZEN_EXAMPLEFIRST = "USE examples or concrete scenarios to clarify vague requirements and anchor abstract logic."
ZEN_BREAKDOWN = "DECOMPOSE the task into independent, traceable subtasks before implementation."
ZEN_OWNWORDS = "REPHRASE the instruction in your OWN WORDS to confirm understanding with the team."
ZEN_NOTHINGIMPLICIT = "TREAT all implicit rules or patterns as unknown until they are verbalized and recorded."
ZEN_TODOFLAG = "IF any portion is unclear, FLAG it with a TODO + rationale before proceeding."
ZEN_BASELINE = "ESTABLISH a BASELINE of current functionality to compare against any proposed change."
ZEN_NAMETHETHING = "NAME the key elements of the task — inputs, flows, outputs — before any coding begins."
ZEN_WHATNOT = "CLARIFY what the task explicitly does NOT cover to avoid assumption creep."
ZEN_DESIGNSPACE = "IDENTIFY all viable SOLUTIONS before committing to one — don't converge too early."
ZEN_TEAMMEMO = "LOG key team decisions and pivots in a single running memo or changelog tied to the task."

SEEK_WHATIS = "ASK: What is this part trying to do, and how would I know if it failed?"
SEEK_WHYHERE = "ASK: Why is this implemented *here* and not somewhere else?"
SEEK_WHOCARES = "ASK: Who benefits from this code working, and who suffers if it breaks?"
SEEK_EDGE = "ASK: What happens at the edges of this feature — inputs, outputs, errors?"
SEEK_PRECEDENT = "ASK: Have we solved a similar problem before, and what did we learn?"
SEEK_ALTERNATE = "ASK: What would this look like if it were done differently — even radically so?"
SEEK_ORIGIN = "ASK: Where did this requirement come from, and is the problem still the same?"
SEEK_SIMPLIFY = "ASK: Is there a simpler framing of this task that preserves the core need?"

TRACE_FLOW = "TRACE the data flow from source to sink — every transformation should be accounted for."
TRACE_DEP = "MAP out all dependencies — internal and external — for the task at hand."
TRACE_IMPACT = "TRACE the blast radius — what else could be unintentionally affected by this change?"
TRACE_PATH = "TRACE the invocation path — what calls this and what does it call downstream?"
TRACE_SIGNAL = "TRACE where signals, events, or state transitions occur across system boundaries."
TRACE_VARIANT = "TRACE alternate execution paths — under different inputs, permissions, or environments."
TRACE_CONTRACT = "TRACE interface contracts — what assumptions are enforced across module boundaries?"
TRACE_HISTORY = "TRACE how this part evolved — what commits or design shifts shaped it?"

FRAME_MINIMUM = "DEFINE the minimum viable outcome for this task — what’s the least we must deliver to claim success?"
FRAME_BLOCKS = "LIST what is missing or blocking progress right now — even if it feels minor."
FRAME_CHOICES = "IDENTIFY key choices made in how this works — could they be made differently?"
FRAME_CONSTRAINTS = "FRAME current constraints as design signals, not obstacles."
FRAME_ITERATE = "CONSIDER what can be delivered in *this* iteration, and what must wait."
FRAME_SLICES = "FRAME the problem in vertical slices — how could a complete thin flow be prototyped?"
FRAME_TENSIONS = "FRAME trade-offs explicitly — what are we gaining and losing with each choice?"
FRAME_TEST = "FRAME how we will test and validate the work — before writing a single line of logic."
